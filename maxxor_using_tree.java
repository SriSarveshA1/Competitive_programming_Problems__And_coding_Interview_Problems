public class maxxor_using_tree {
    public class node{
        node left;// 0th bit value  we are going to create to pointer variable for each node ..when we insert a value in the left pointer it means we are inserting 0 value
        node right;//1st bit value  we create a right node similarly when we want to insert a value in the right pointer it means we are inserting 1 value 
        node()
        {
            left=null;//we inittially make both the left and right pointer points to null inititally
            right=null;
        }
    }
    node root;//we create a top most root of a trie that has '\u0000'
    maxxor_using_tree()
    {
        root=new node();
    }
    void insert(int n)
    {
       node temp=root;// we start inserting from thhe top most root node 
       // when we have a n=5   000000...101 total 32 bits (31-0)bits =32    we need to insert all these 32 bits into the trie by retriving bits from each bit of the number .. for example if we want to retrive the bit value at the 31st bit we do (n>>31)&1 =which will give 31st bit value..if we want to retrive any ith bit from a number n we use (n>>i)&1 to get it.
       for(int i=31;i>=0;i--)
       {
           int bit=(n>>i)&1;
           if(bit==0)
           {
               if(temp.left==null)//if there is no left node present the temp will be pointing to null.
               {
                   temp.left=new node();//so we need to create a new node and make the temp's left point to that new node.
               }
               temp=temp.left;//Thn make the temp to point to temp's left.
           }
           else{//if the bit that we are going to insert is 1 then we need to insert it to the right 
               if(temp.right==null)//if there is no previous right node inserted means no 1 is present..so we need to create a new node
               {
                     temp.right=new node();//and make the temp.rigt points to that node.

               }
               temp=temp.right;//thn we need to make our temp to point to the temps right node.
           }
       }
    }
    int max_xor(int value)//at last we will return a number(which is xor of value and (maximum number that be generated by complimenting all the bits in the value number)) but when we try to compliment a number it should already present in the trie
    {
      node temp=root;
      int current_max_xor=0;
      for(int j=31;j>=0;j--)
      {
          int bit=(value>>j)&1;
          if(bit==0)
          {
              if(temp.right!=null)//we are checking for the complement value that is 1
              {
                 temp=temp.right;
                 current_max_xor+=(1<<j);//we are getting the 2^j th value so that by combining all the 2^j values we can retrive the overall value. ex consider  1   0   0   1
              }                                                                                                                                               // 2^3 + 0 + 0 + 2^0   sum=9
              else{//if the complement bit is not present we simply come to the left bit that is 0 
                  temp=temp.left;//when there is no complement bit is present this will not contribute any value in the answer
              }
          }
          else{
              if(temp.left!=null)
              {
                  temp=temp.left;
                  current_max_xor+=(1<<j);
              }
              else{
                  temp=temp.right;
              }
          }
      }
      return current_max_xor;// we return the maximum xor anser that we can generate using the current value
    }
    void max_xor_helper(int[] array)
    {
         int max_xxor=0;//we initially keep the max_xor to 0 before checking when we enter the other values
         for(int i=0;i<array.length;i++)// what we are basically doing is we are inserting each element into the trie from the array and computing the max_xor each time when we insert a new value .
         {
             int val=array[i];
              insert(val);
             int curr_xor=max_xor(val);//max_xor can be found by calling this function.This fucntion generally checks how it can find the maximum xor from (val and the number x ....val^x ) this x is the number that we need to find in the trie                           val=  0    0   1    0    0    1
             max_xxor=Integer.max(max_xxor, curr_xor);                                                                                                                                                                                                               //        x= 0/1  0/1 0/1  0/1  0/1  0/1  we go to 0/1 according to which is avaliable ..we try to go to the complement bit of each bit .. but we go that if and only if we have pointer that points to either left or right
                                                                                                                                                                                                                                                                  //cur_max_xor=                              (we return the integer value of the cur_max_xor)using (1<<j) j is the bit we are in .
         }                                                                                                                                                                                                                                                                    
         System.out.println(max_xxor);                                                                                                                                                                                                                                                     
    }



    public static void main(String[] args)
    {
         
        maxxor_using_tree t=new maxxor_using_tree();
        int[] ar={3,5,10,8};
        t.max_xor_helper(ar);
      
;
    }
}
